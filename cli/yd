#!/usr/bin/env ruby

## libraries
# stdlib
require 'pathname'
require 'tmpdir'
# external
require 'commander/import'
never_trace!
require 'highline/import'
require 'rest_client'

API_VERSION=1

class YarddogConf

    def initialize dir
        if dir && (path = "#{dir}/.yarddog.conf") && File.exists?(path)
            @file = File.new path
        elsif ENV['HOME'] && (path = "#{ENV['HOME']}/.yarddog.conf") && File.exists?(path)
            @file = File.new path
        else
            fail "No config file found. Please create one and put at least your API token on a line beginning with ‘token = ’"
        end

        @file.each do |line| line.match /(url = |token = )(.*)/ do |match|
            if match[1] == 'url = '
                @url = match[2]
            elsif match[1] == 'token = '
                @token = match[2]
            end
        end end

        unless @token
            fail "No token found. Please create one and put at least your API token on a line beginning with ‘token = ’ in your config file"
        end
    end

    attr_reader :url, :token

end

class Rest
    DEFAULT_URL = 'http://localhost:3000/api/v1/'

    def initialize args, options
        @args = args
        @options = options
        @conf = YarddogConf.new(options.dir || Dir.getwd)
        @token = @conf.token
        resolve_url
        @site = RestClient::Resource.new(@url)
    end

    protected
    def resolve_url
        if @options.url
            @url = @options.url
        elsif ENV["YARDDOG_URL"] && !ENV["YARDDOG_URL"].empty?
            @url = ENV["YARDDOG_URL"]
        elsif @conf.url
            @url = @conf.url
        else
            warn "Using the default URL #{DEFAULT_URL}." 
            @url = DEFAULT_URL
        end
        @url += '/' unless @url.end_with? '/'
        validator = %r|api/v#{API_VERSION}/$|
        unless @url =~ validator
            fail "Improper API Version or invalid URL. You provided ‘#{@url}’ but the required API version is v#{API_VERSION}"
        end
    end

end

class Runner < Rest
    TARNAME = 'source.tar'
    GZNAME  = 'source.tar.gz'

    def initialize args, options
        super args, options
        @dir = resolve_dir Pathname.new(options.dir || Dir.getwd)
    end

    def run
        begin
            tar, sha = make_tar
            request = {sha1: sha, token: @token, source_tgz: tar}
            request[:type] = @options.type if @options.type
            request[:args] = @args unless @args.empty?
            puts request.inspect
            send! request
        rescue Exception => e
            FileUtils.remove_entry @tmp
            raise e
        end
    end

    protected
    def send! request
        tar = request[:source_tgz]
        begin
            request.delete :source_tgz
            response1 = @site['runs'].post request
        rescue RestClient::RequestFailed => e
            if e.http_code == 400
                request[:source_tgz] = tar
                request.delete :sha1
                response2 = @site['runs'].post request
            end
        end
    end

    # make sure to delete the tar afterward
    protected
    def make_tar
        warn 'The container will be started using the commands in the Dockerfile.' if @args.empty?
        @tmp = Dir.mktmpdir
        tarname = "#{@tmp}/#{TARNAME}"
        gzname  = "#{@tmp}/#{GZNAME}"
        unless system "tar -c -f #{tarname} #{@dir} 2>/dev/null"
            fail "Could not make tar in #{tarname}"
        end
        unless system "gzip -nk #{tarname}"
            fail "Could not gzip #{tarname} into #{gzname}"
        end
        shasum = `shasum #{tarname}`.split()[0]
        puts "made tar #{tarname}, sha = #{shasum}" if $DEBUG
        file = File.new gzname
        return [file, shasum]
    end

    protected
    def resolve_dir path
        if path.directory?
            if (path + 'Dockerfile').exist?
                return path
            else
                fail "The directory specified (#{path}) does not have a Dockerfile"
            end
        elsif path.file?
            puts path.basename
            if path.basename.to_s == 'Dockerfile' 
                # might want to add a check here if the file is actually a Dockerfile and not just named that.
                return path.dirname
            else
                fail 'You did not specify a valid Dockerfile'
            end
        else
            fail "Invalid path (#{path})"
        end
    end

end

class Scheduler < Runner

    def initialize args, options
        unless options.cron
            fail 'The schedule command requires the -c option. Try schedule --help for more information'
        end
        super args, options
    end

    def schedule
        # TODO: api not finished yet
        # probably something like:
        # tar, sha = make_tar
        # request[:schedule] = @options.cron
        # request = {sha1: sha, token: @token}
        # request[:type] = @options.type if @options.type
        # request[:args] = @args if @args
        # send! request
    end

end


class Getter < Rest

    def status
        if @args.empty?
            response = @site['runs'].get params: {token: @token}
            puts response.to_s
        else
            response = @site['runs/' + @args[0]].get params: {token: @token}
            puts response.to_s
        end
    end

    def stop
        fail 'Please provide a job ID to terminate.' if @args.empty?
        response = @site['runs' + @args[0].to_s].delete params: {token: @token}
        puts response.to_s
    end

    def user_info
        response = @site['users/' + @args[0].to_s].get params: {token: @token}
        puts response.to_s
    end

    def create_user
        response = @site['users'].post email: @args.join, token: @token
        puts response.to_s
    end

    def delete_user
        response = @site['users/' + @args[0].to_s].delete params: {token: @token}
        puts response.to_s
    end

end

## commander config
program :version, '0'
program :description, 'CLI for Yarddog, a utility to manage docker containers in virtual servers'

command :run do |c|
    c.syntax = 'yd run [-d directory/Dockerfile] [-u url] [-t type] -- <command [args...]>'
    c.description = 'Build a docker image and run <command> on the cluster.'
    c.option '-d', '--dir directory/Dockerfile', String, 'specify the directory with a Dockerfile at its root.'
    c.option '-u', '--url http://localhost:3000', String, 'specify the URL of the yarddog server'
    c.option '-t', '--type instance_type', String, 'specify the type of instance on which the command should be run'
    c.action { |args, options| Runner.new(args, options).run }
end

command :schedule do |c|
    c.syntax = 'yd schedule [-d directory/Dockerfile] [-u url] <-c "quoted cron string"> -- <command [args...]>'
    c.description = 'Schedule a run command to happen in the future or periodically.'
    c.option '-d', '--dir directory/Dockerfile', String, 'specify the directory with a Dockerfile at its root.'
    c.option '-u', '--url http://localhost:3000', String, 'specify the URL of the yarddog server'
    c.option '-t', '--type instance_type', String, 'specify the type of instance on which the command should be run'
    c.option '-c', '--cron "cronjob string"', String, 'use cron syntax to specify a schedule for the command. This option is required. IMPORTANT: Make sure your cron string is "enquoted", otherwise the shell may expand special characters and the <command [args...]> will be incorrect.'
    c.action { |args, options| Scheduler.new(args, options).schedule }
end

command :status do |c|
    c.syntax = 'yd status [-u url] [jobid]'
    c.description = 'Get the status of a command running now or scheduled later.'
    c.option '-u', '--url http://localhost:3000', String, 'specify the URL of the yarddog server'
    c.action { |args, options| Getter.new(args, options).status }
end
alias_command :ls, :status

command :stop do |c|
    c.syntax = 'yd stop [-u url] <jobid>'
    c.option '-u', '--url http://localhost:3000', String, 'specify the URL of the yarddog server'
    c.description = 'Attempt to stop a running command by its <jobid>'
    c.action { |args, options| Getter.new(args, options).stop }
end
